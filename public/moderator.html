<!-- filepath: /Users/chris/Documents/Github/Live_Q-A/public/moderator.html -->
<!DOCTYPE html>
 <html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Moderator Panel</title>
  <style>
    body {
      font-family: sans-serif;
      padding: 20px;
      background: linear-gradient(to right, #0F181B, #0D2734); /* Gradient from left to right */
      color: #D7E5D9; /* Light text color */
    }

    button {
      background-color: #D7E5D9;
      color: #0D2734; /* Dark text */
      border: none; /* Remove border */
      padding: 10px 20px; /* Add padding */
      text-align: center; /* Center text */
      text-decoration: none; /* Remove underline */
      display: inline-block; /* Inline-block for layout */
      font-size: 1em; /* Font size */
      margin: 5px 0; /* Add margin */
      cursor: pointer; /* Pointer cursor on hover */
      border-radius: 0; /* Rounded corners */
      transition: background-color 0.3s ease; /* Smooth hover effect */
    }

    button:hover {
      background-color: #D7E5D9; /* Light background on hover */
    }

    #sorting-controls {
      margin-bottom: 20px; /* Add spacing below the sorting controls */
    }
    #questions div { margin: 0; padding: 10px;}
    .question {
      display: flex;
      flex-direction: column; /* Stack children vertically */
      justify-content: flex-start;
      align-items: flex-start;
      margin-bottom: 15px;
      padding: 10px;
      border: 1px solid #ccc;
    }
    .question-text {
      font-size: 1em;
      margin-bottom: 10px; /* Add spacing between the question text and buttons */
      border: none;
    }
    .buttons button {
      margin-right: 5px; /* Add spacing between buttons */
    }  
    .live {
      color:#0F181B;
      background-color: yellow;
    }

    .approved {
      font-weight: bold;
      background-color:#235b61; /* Light background for approved questions */
    }

    #archived-questions {
      border: 1px solid #ccc;
      padding: 10px;
      background-color: #f9f9f9;
    }
    .archived-question {
      margin-bottom: 10px; /* Add spacing between questions */
      padding: 10px; /* Add padding inside each question block */
      border-bottom: 1px solid #ddd; /* Optional: Add a separator between questions */
    }
    .archived-date {
      font-size: 0.9em;
      color: #666;
      margin-top: 5px; /* Add spacing between the question text and the date */
    }
    .timestamp {
      font-size: 0.8em;
      color: #aaa;
      margin-top: 5px;
    }
    #top-panel {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 20px;
    }
    #sorting-controls {
      flex-grow: 1;
    }
    #live-question-area {
      flex-basis: 50%;
      margin-left: 20px;
      /* Removed border: 2px solid yellow; */
      padding: 10px;
      border-radius: 5px;
    }
    #live-question-area .question {
      /* background-color: transparent; // Removed */
      border: none;
    }
    #next-up-question-area {
      flex-basis: 50%;
      margin-left: 20px;
      padding: 10px;
      border-radius: 5px;
    }
  </style>
</head>
<body>
  <h1>Moderator Panel</h1>
  <button onclick="window.location.href='/moderator_logout'">Logoff</button>
  <button id="configure-event-button" onclick="toggleConfigureEvent()">Configure Event</button>

  <div id="configure-event" style="display: none; margin-top: 20px; border: 1px solid #ccc; padding: 10px;">
    <h3>Event Configuration</h3>
    <label for="event-name">Event Name:</label>
    <input type="text" id="event-name" placeholder="Enter event name"><br><br>

    <label for="event-url-field">URL:</label>
    <input type="text" id="event-url-field" placeholder="Example: 01.02.03.04"><br><br>

    <label for="event-datetime">Event Date and Time:</label>
    <input type="datetime-local" id="event-datetime" placeholder="Select event date and time"><br><br>

    <button onclick="saveEventConfig()">Update</button>
  </div>

  <!-- Top panel for sorting and live question -->
  <div id="top-panel">
    <!-- Add sorting buttons -->
    <div id="sorting-controls">
      <button onclick="changeSort('recency')">Sort by Recency</button>
      <button onclick="changeSort('approved')">Sort by Approved</button>
      <button onclick="changeSort('votes')">Sort by Votes</button>
    </div>
    <!-- Live question area -->
    <div id="live-question-area"></div>
    <!-- Next Up question area -->
    <div id="next-up-question-area"></div>
  </div>

  <!-- Question list container -->
  <div id="questions"></div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io();
    let currentSort = 'recency'; // Default sort order

    // Listen for all questions and update the list
    socket.on('all_questions', (questions) => {
      updateQuestionList(questions);
    });

    socket.on('live_question', (question) => {
      const liveQuestionArea = document.getElementById('live-question-area');
      if (question) {
        liveQuestionArea.innerHTML = `
          <h3>Live Question</h3>
          <div class="question live" data-id="${question.id}">
            <div class="question-text">${question.text} | <span class="vote-count">Votes: ${question.upvotes}</span></div>
            <div class="username">Submitted by: ${question.username}</div>
            <div class="timestamp">Submitted on: ${new Date(question.created_at).toLocaleString()}</div>
            <div class="buttons">
              <button onclick="cancelLive('${question.id}')">Cancel</button>
              <button onclick="archive_question('${question.id}')">Archive</button>
            </div>
          </div>
        `;
      } else {
        liveQuestionArea.innerHTML = '';
      }
    });

    socket.on('next_up_question', (question) => {
      const nextUpQuestionArea = document.getElementById('next-up-question-area');
      if (question) {
        nextUpQuestionArea.innerHTML = `
          <h3>Next Up</h3>
          <div class="question" data-id="${question.id}">
            <div class="question-text">${question.text} | <span class="vote-count">Votes: ${question.upvotes}</span></div>
            <div class="username">Submitted by: ${question.username}</div>
            <div class="timestamp">Submitted on: ${new Date(question.created_at).toLocaleString()}</div>
            <div class="buttons">
              <button onclick="markAsLive('${question.id}')">Live</button>
              <button onclick="cancelNextUp('${question.id}')">Cancel</button>
            </div>
          </div>
        `;
      } else {
        nextUpQuestionArea.innerHTML = '';
      }
    });

    // Update the question list based on the current sort order
    function updateQuestionList(questions) {
      const container = document.getElementById('questions');
      container.innerHTML = '';

      const nonLiveQuestions = questions.filter(q => q.status !== 'live' && q.status !== 'next_up');

      nonLiveQuestions.forEach((q) => {
        const div = document.createElement('div');
        div.className = 'question';
        div.setAttribute('data-id', q.id); // Add a data-id attribute

        // Debugging: Log the participant IDs being compared
        console.log('Moderator receiving a question participantID:', q.participant_id);

        // Add styles for live and approved questions
        if (q.status === 'live') {
          div.classList.add('live'); // Highlight live questions
        }
        if (q.status === 'approved') {
          div.classList.add('approved'); // Style approved questions
        }

        // Render buttons conditionally
        let buttons = '';
        if (q.status === 'live') {
          buttons = `
            <div class="buttons">
              <button onclick="cancelLive('${q.id}')">Cancel</button>
              <button onclick="archive_question('${q.id}')">Archive</button>
            </div>
          `;
        } else {
          buttons = `
            <div class="buttons">
              <button onclick="markAsLive('${q.id}')">Live</button>
              ${q.status === 'approved' 
                ? `<button onclick="unapprove('${q.id}')">Unapprove</button>` 
                : `<button onclick="approve('${q.id}')">Approve</button>`}
              <button onclick="delete_question('${q.id}')">Delete</button>
              ${q.status !== 'live' && q.status !== 'approved' 
                ? `<button onclick="editQuestion('${q.id}')">Edit</button>` 
                : ''}
              ${q.status !== 'live' && q.status !== 'approved'
                ? `<button onclick="markAsNextUp('${q.id}')">Next Up</button>`
                : ''}
            </div>
          `;
        }

        div.innerHTML = `
          <div class="question-text">${q.text} | <span class="vote-count">Votes: ${q.upvotes}</span></div>
          <div class="username">Submitted by: ${q.username}</div>
          <div class="timestamp">Submitted on: ${new Date(q.created_at).toLocaleString()}</div>
          ${buttons}
        `;
        container.appendChild(div);
      });
    }

    // Mark a question as live
    function markAsLive(id) {
      socket.emit('moderator_action', { id, action: 'live', sortBy: currentSort });
    }

    // Mark a question as next up
    function markAsNextUp(id) {
      socket.emit('moderator_action', { id, action: 'next_up', sortBy: currentSort });
    }

    // Cancel next up status
    function cancelNextUp(id) {
      socket.emit('moderator_action', { id, action: 'cancel_next_up', sortBy: currentSort });
    }

    // Cancel live status
    function cancelLive(id) {
      socket.emit('moderator_action', { id, action: 'cancel_live', sortBy: currentSort });
    }

    // Approve a question
    function approve(id) {
      socket.emit('moderator_action', { id, action: 'approved', sortBy: currentSort });
    }

    // Unapprove a question
    function unapprove(id) {
      socket.emit('moderator_action', { id, action: 'unapprove', sortBy: currentSort });
    }

    // delete a question
    function delete_question(id) {
      socket.emit('moderator_action', { id, action: 'questiondeleted', sortBy: currentSort });
    }

    // Archive a question
    function archive_question(id) {
      socket.emit('moderator_action', { id, action: 'cancel_live', sortBy: currentSort });
      socket.emit('moderator_action', { id, action: 'archive', sortBy: currentSort });
    }

    // Change the sort order
    function changeSort(order) {
      currentSort = order; // Update the current sort order
      socket.emit('request_questions', { sortBy: currentSort }); // Request sorted questions from the server
    }

    // Update vote count in real-time
    socket.on('update_vote', (updatedQuestion) => {
      // Find the question element in the DOM
      const questionElement = document.querySelector(`.question[data-id="${updatedQuestion.id}"]`);
      if (questionElement) {
        // Update the vote count in the DOM
        const voteCountElement = questionElement.querySelector('.vote-count');
        if (voteCountElement) {
          voteCountElement.textContent = `Votes: ${updatedQuestion.upvotes}`;
        }
      }
    });

    // Toggle Configure Event Section
    function toggleConfigureEvent() {
      const configDiv = document.getElementById('configure-event');
      const button = document.getElementById('configure-event-button');

      if (configDiv.style.display === 'none') {
        configDiv.style.display = 'block';
        button.textContent = 'Close Configuration';
      } else {
        configDiv.style.display = 'none';
        button.textContent = 'Configure Event';
      }
    }

    // Save Event Configuration
    function saveEventConfig() {
      const modeventName = document.getElementById('event-name').value;
      const moderatorEventURL = document.getElementById('event-url-field').value;
      const modeventDatetime = document.getElementById('event-datetime').value;
      const eventName = document.getElementById('event-name').value;
      const eventURL = document.getElementById('event-url-field').value;
      const eventDatetime = document.getElementById('event-datetime').value;

      // Emit the event to the server with the event configuration values
      socket.emit('save_event_config', { eventName, eventURL, eventDatetime });

      // Save values to localStorage
      localStorage.setItem('modeventName', modeventName);
      localStorage.setItem('modeventURL', moderatorEventURL);
      localStorage.setItem('modeventDatetime', modeventDatetime);

      alert('Event configuration saved!');
    }

    function loadEventConfig() {
      const modeventName = localStorage.getItem('modeventName') || 'VBC Live Event';
      const moderatorEventURL = localStorage.getItem('moderatorEventURL') || 'e.g. 10.10.20.20';
      const modeventDatetime = localStorage.getItem('modeventDatetime') || '';
      // Populate the fields with values from localStorage or default values
      document.getElementById('event-name').value = modeventName;
      document.getElementById('event-url-field').value = moderatorEventURL;
      document.getElementById('event-datetime').value = modeventDatetime;
    }

    // Call loadEventConfig when the page loads
    window.onload = loadEventConfig;

    function exportQuestions() {
      // Fetch all questions and archived questions from the server
      socket.emit('request_export_data');

      // Listen for the server response
      socket.on('export_data', ({ questions, archivedQuestions }) => {
        // Combine questions and archived questions into a single array
        const allQuestions = [
          ...questions.map(q => ({
            id: q.id,
            username: q.username || 'Anonymous',
            text: q.text,
            status: q.status,
            upvotes: q.upvotes,
            created_at: new Date(q.created_at).toLocaleString(),
          })),
          ...archivedQuestions.map(q => ({
            id: q.id,
            username: q.username || 'Anonymous',
            text: q.text,
            status: q.status,
            upvotes: q.upvotes,
            created_at: new Date(q.created_at).toLocaleString(),
            archived_at: new Date(q.archived_at).toLocaleString(),
          })),
        ];

        // Convert the data to CSV format
        const csvContent = convertToCSV(allQuestions);

        // Create a downloadable link for the CSV file
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = 'questions_export.csv';
        link.style.display = 'none';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      });
    }

    // Helper function to convert data to CSV format
    function convertToCSV(data) {
      const headers = Object.keys(data[0]).join(','); // Extract headers from the first object
      const rows = data.map(row => Object.values(row).join(',')); // Convert each object to a CSV row
      return [headers, ...rows].join('\n'); // Combine headers and rows into a single CSV string
    }
  </script>

  <!-- Toggle Archived Questions Button -->
  <button id="toggle-archived" onclick="toggleArchivedQuestions()">Show Archived Questions</button>

  <!-- Archived Questions Section -->
  <div id="archived-questions" style="display: none; margin-top: 20px;">

    <h3>Archived Questions</h3>
    <div id="archived-questions-list"></div>
  </div>

  <script>
    let archivedVisible = false;

    function toggleArchivedQuestions() {
      const archivedContainer = document.getElementById('archived-questions');
      const toggleButton = document.getElementById('toggle-archived');

      if (archivedVisible) {
        archivedContainer.style.display = 'none';
        toggleButton.textContent = 'Show Archived Questions';
      } else {
        // Fetch archived questions from the server when showing the list
        socket.emit('request_archived_questions');
        archivedContainer.style.display = 'block';
        toggleButton.textContent = 'Hide Archived Questions';
      }

      archivedVisible = !archivedVisible;
    }

    socket.on('archived_questions', (questions) => {
      const container = document.getElementById('archived-questions-list');
      container.innerHTML = '';

      questions.forEach((q) => {
        const div = document.createElement('div');
        div.className = 'archived-question';
        div.innerHTML = `
          <div>${q.text}</div>
          <div class="archived-date">Archived on: ${new Date(q.archived_at).toLocaleString()}</div>
          <button onclick="unarchiveQuestion('${q.id}')">Unarchive</button>
        `;
        container.appendChild(div);
      });
    });

    function unarchiveQuestion(id) {
      socket.emit('moderator_action', { id, action: 'unarchive', sortBy: currentSort });
    }

    // Function to enable editing of a question
    function editQuestion(id) {
      const questionElement = document.querySelector(`.question[data-id="${id}"]`);
      if (!questionElement) return;

      const questionTextElement = questionElement.querySelector('.question-text');
      const originalText = questionTextElement.textContent.split(' | ')[0]; // Get original text, excluding votes

      // Create a textarea for editing
      const textarea = document.createElement('textarea');
      textarea.value = originalText;
      textarea.rows = 3;
      textarea.style.width = '100%';
      textarea.style.boxSizing = 'border-box'; // Include padding and border in the element's total width and height

      // Replace the question text with the textarea
      questionTextElement.innerHTML = '';
      questionTextElement.appendChild(textarea);

      // Hide Edit button, show Save and Cancel
      const buttonsDiv = questionElement.querySelector('.buttons');
      buttonsDiv.querySelector('button[onclick*="editQuestion"]').style.display = 'none';

      const saveButton = document.createElement('button');
      saveButton.textContent = 'Save';
      saveButton.onclick = () => saveEditedQuestion(id, textarea.value);
      buttonsDiv.appendChild(saveButton);

      const cancelButton = document.createElement('button');
      cancelButton.textContent = 'Cancel';
      cancelButton.onclick = () => cancelEdit(id, originalText);
      buttonsDiv.appendChild(cancelButton);
    }

    // Function to save the edited question
    function saveEditedQuestion(id, newText) {
      socket.emit('moderator_action', { id, action: 'edit', newText, sortBy: currentSort });
    }

    // Function to cancel editing a question
    function cancelEdit(id, originalText) {
      const questionElement = document.querySelector(`.question[data-id="${id}"]`);
      if (!questionElement) return;

      const questionTextElement = questionElement.querySelector('.question-text');
      // Restore original text
      questionTextElement.innerHTML = `${originalText} | <span class="vote-count">Votes: ${questionElement.querySelector('.vote-count').textContent.split(': ')[1]}</span>`;

      // Show Edit button, hide Save and Cancel
      const buttonsDiv = questionElement.querySelector('.buttons');
      buttonsDiv.querySelector('button[onclick*="editQuestion"]').style.display = '';
      buttonsDiv.querySelector('button[onclick*="saveEditedQuestion"]').remove();
      buttonsDiv.querySelector('button[onclick*="cancelEdit"]').remove();
    }
  </script>

  <!-- Export Questions Button -->
  <div id="export-controls" style="margin-top: 20px;">
    <button onclick="exportQuestions()">Export Questions</button>
  </div>
  
</body>
</html>